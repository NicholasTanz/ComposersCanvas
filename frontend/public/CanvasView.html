<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Interactive Staff Notes</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/vexflow/4.2.5/vexflow-min.js"></script>    
    <script src="https://unpkg.com/tone@15.0.4/build/Tone.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/html2pdf.js/0.9.3/html2pdf.bundle.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/axios@1.8.4/dist/axios.min.js"></script>
    <style>
        body {
            padding-top: 80px; 
            background: #d9e9f4; 
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            justify-content: center;
            overflow-x: hidden; 
          }
      
        .fixed-toolbar {
        position: fixed;
        top: 0;
        left: 0;
        right: 0;
        background: white;
        border-bottom: 1px solid #ddd;
        padding: 8px 16px;
        display: flex;
        flex-wrap: nowrap;
        align-items: center;
        gap: 12px;
        z-index: 1000;
        height: 60px;
        box-shadow: 0 2px 6px rgba(0, 0, 0, 0.05);
        }
    
        .fixed-toolbar button {
        background: #ffffff;
        border: 1px solid #ffffff;
        border-radius: 4px;
        padding: 6px;
        transition: all 0.2s ease;
        cursor: pointer;
        }
    
        .fixed-toolbar button:hover {
        background: #1d4ed8; 
        }
    
        .fixed-toolbar img {
        width: 32px;
        height: 32px;
        }
    
        .tutorial-container {
        position: relative;
        margin-left: auto; 
        }
    
        .tutorial-btn {
        background: #ffffff;
        border: 1px solid #ffffff;
        border-radius: 4px;
        padding: 6px 10px;
        cursor: pointer;
        transition: background 0.2s;
        }
    
        .tutorial-btn:hover {
        background: #1d4ed8;
        color: white;
        }
    
        .tutorial-dropdown {
        display: none;
        position: absolute;
        right: 0;
        top: 100%;
        background: white;
        border: 1px solid #ddd;
        border-radius: 6px;
        box-shadow: 0 4px 8px rgba(0,0,0,0.1);
        padding: 10px;
        width: 260px;
        z-index: 1001;
        font-size: 14px;
        color: #333;
        line-height: 1.4;
        margin-top: 4px;
        }
        
        .tutorial-container.active .tutorial-dropdown {
        display: block;
        }
    
        #note-selection {
        position: relative;
        display: inline-block;
        }
    
        #note-options {
        display: none;
        position: absolute;
        top: 50px;
        left: 0;
        background: white;
        border: 1px solid #ddd;
        border-radius: 6px;
        box-shadow: 0 4px 8px rgba(0,0,0,0.1);
        padding: 8px;
        gap: 6px;
        }
    
        #note-selection:hover #note-options,
        #note-options:focus-within {
        display: flex;
        flex-direction: row;
        }
    
        .note-option img, 
        #rest-button img, 
        #play-button img, 
        #pause-button img {
        width: 28px;
        height: 28px;
        transition: transform 0.2s;
        }
    
        .note-option img:hover,
        #rest-button img:hover,
        #play-button img:hover,
        #pause-button img:hover {
        transform: scale(1.1);
        }
    
        #rest-button.active {
        background-color: #dbe6e9;
        border: 1px solid #aad3df;
        }
    
        input, button {
        font-size: 14px;
        }
    
        input {
        padding: 6px;
        border-radius: 4px;
        border: 1px solid #ccc;
        }
    
        button {
        border-radius: 4px;
        padding: 6px 10px;
        background: #f9f9f9;
        border: 1px solid #ffffff;
        cursor: pointer;
        transition: background 0.2s;
        }
    
        button:hover {
        background: #1d4ed8; 
        }
    
        #my-stave {
        margin-top: 30px;
        padding: 15px;
        background: white;
        border: 1px solid #ddd;
        border-radius: 8px;
        box-shadow: 0 2px 4px rgba(0,0,0,0.05);
        }
    
        #notes-display {
        margin-top: 20px;
        font-family: monospace;
        font-size: 13px;
        color: #444;
        background: #fff;
        border: 1px solid #ddd;
        padding: 10px;
        border-radius: 6px;
        }
    
        #settings-container {
        margin: 20px 0;
        max-width: 400px;
        }
    
        #settings-toggle {
        background: #f0f0f0;
        border: 1px solid #ccc;
        border-radius: 8px;
        padding: 8px 12px;
        cursor: pointer;
        width: 100%;
        text-align: left;
        font-weight: bold;
        transition: background 0.2s;
        }
    
        #settings-toggle:hover {
        background: #e0e0e0;
        }
    
        #settings-panel {
        margin-top: 8px;
        padding: 15px;
        background: #ffffff;
        border: 1px solid #ccc;
        border-radius: 8px;
        box-shadow: 0 2px 4px rgba(0,0,0,0.05);
        transition: max-height 0.3s ease, opacity 0.3s ease, padding 0.3s ease;
        overflow: hidden;
        }
    
        #settings-panel.collapsed {
        max-height: 0;
        opacity: 0;
        padding: 0 15px;
        pointer-events: none;
        }
    
        #settings-panel:not(.collapsed) {
        max-height: 500px; 
        opacity: 1;
        pointer-events: auto;
        }

        .settings-row {
        display: flex;
        gap: 20px;
        margin-bottom: 10px;
        }

        .input-group {
            display: flex;
            flex-direction: column;
            flex: 1;
        }

        .time-inputs {
            display: flex;
            align-items: center;
            gap: 5px;
        }

        .save-section {
            border-top: 1px solid #ccc;
            margin-top: 20px;
            padding-top: 10px;
            display: flex;
            flex-direction: column;
            align-items: flex-start;
        }
        
        .input-group {
        margin-bottom: 12px;
        }
    
        .input-group label {
        display: block;
        margin-bottom: 4px;
        font-weight: 500;
        color: #555;
        }
    
        .input-group input {
        padding: 6px 8px;
        border: 1px solid #ccc;
        border-radius: 4px;
        margin-right: 5px;
        width: calc(100% - 12px);
        }
    
        .time-inputs {
        display: flex;
        align-items: center;
        gap: 5px;
        }
    
        .time-inputs input {
        width: 60px;
        }
    
        .time-inputs span {
        font-weight: bold;
        }
    
        .input-group button {
        margin-top: 5px;
        background: #f0f0f0;
        border: 1px solid #bbb;
        border-radius: 4px;
        padding: 5px 10px;
        cursor: pointer;
        transition: background 0.2s;
        }
    
        .input-group button:hover {
        background: #e0e0e0;
        }
    
        .floating-back {
        position: fixed;
        bottom: 20px;
        left: 20px;
        border-radius: 50%;
        width: 50px;
        height: 50px;
        background-color: #1d4ed8; 
        color: white;
        display: flex;
        align-items: center;
        justify-content: center;
        font-size: 18px;
        transition: background 0.2s;
        }
    
        .floating-back:hover {
        background-color: #2563eb; 
        }
        .invisible-buttons {
        display: none !important;
        }
        
        </style>
      </head>
      <body>
        <a href="/profile" class="floating-back">‚Üê</a>
        <div>
          <div class="fixed-toolbar">
            <div id="note-selection">
              <button id="note-button">
                <img src="images/quarter.png" alt="Quarter Note" id="note-icon" style="width: 40px; height: 40px;">
              </button>
              <div id="note-options" class="hidden">
                <button class="note-option" data-value="w"><img src="images/whole.svg" alt="Whole Note"></button>
                <button class="note-option" data-value="hd"><img src="images/dotted.svg" alt="Dotted Half Note"></button>
                <button class="note-option" data-value="h"><img src="images/half.png" alt="Half Note"></button>
                <button class="note-option" data-value="q"><img src="images/quarter.png" alt="Quarter Note"></button>
                <button class="note-option" data-value="8"><img src="images/eighth.png" alt="Eighth Note"></button>
                <button class="note-option" data-value="16"><img src="images/sixteenth.png" alt="Sixteenth Note"></button>
              </div>
            </div>
            <button id="rest-button">
              <img src="images/rest.png" alt="Rest" style="width: 40px; height: 40px;">
            </button>
            <button id="play-button">
              <img src="images/play.svg" alt="Play" style="width: 40px; height: 40px;">
            </button>
            <button id="pause-button">
              <img src="images/pause.svg" alt="Pause" style="width: 40px; height: 40px;">
            </button>
            
            <div class="tutorial-container" id="tutorial-container">
              <button class="tutorial-btn" id="tutorial-btn">Tutorial</button>
              <div class="tutorial-dropdown">
                <strong>Key Bindings:</strong><br>
                a: add note<br>
                w: go up<br>
                s: go down<br>
                delete: delete<br>
                r: rests<br>
                1-6: note types<br>
                shift: half up/down<br>
                shift+click: select multiple
              </div>
            </div>
          </div>
        </div>
        <div id="settings-container">
            <button id="settings-toggle">‚öôÔ∏è Score Settings</button>
          
            <div id="settings-panel" class="collapsed">
              <h3>Score Settings</h3>
          
              <div class="settings-row">
                <div class="input-group">
                  <label for="score-title">Score Title:</label>
                  <input type="text" id="score-title" placeholder="Enter Title" />
                </div>
                <div class="input-group">
                  <label for="key-signature">Key Signature:</label>
                  <input type="text" id="key-signature" placeholder="e.g., C, G, F#, Bb" />
                </div>
              </div>
          
              <div class="settings-row">
                <div class="input-group">
                  <label for="numerator">Time Signature:</label>
                  <div class="time-inputs">
                    <input type="number" id="numerator" placeholder="4" min="1" />
                    <span>/</span>
                    <input type="number" id="denominator" placeholder="4" min="1" />
                  </div>
                </div>
                <div class="input-group">
                  <label for="tempo">Tempo:</label>
                  <input type="text" id="tempo" placeholder="120" />
                </div>
              </div>
          
              <div class="settings-row">
                <div class="input-group invisible-buttons">
                  <button id="update-title">Set Title</button>
                  <button id="update-key">Set Key</button>
                  <button id="update-time">Set Time Signature</button>
                  <button id="set-tempo">Set Tempo</button>
                </div>
              </div>
          
              <div class="settings-row">
                <div class="input-group" style="flex: 1;">
                    <label for="instrumentDropdown">Instrument:</label>
                    <select id="instrumentDropdown" name="instrument">
                        <option value="Bass (Electric)">Bass (Electric)</option>
                        <option value="Bassoon">Bassoon</option>
                        <option value="Cello">Cello</option>
                        <option value="Clarinet">Clarinet</option>
                        <option value="Double Bass">Double Bass</option>
                        <option value="Flute">Flute</option>
                        <option value="French Horn">French Horn</option>
                        <option value="Guitar (Acoustic)">Guitar (Acoustic)</option> <!-- Default option -->
                        <option value="Guitar (Electric)">Guitar (Electric)</option>
                        <option value="Guitar (Nylon)">Guitar (Nylon)</option>
                        <option value="Harmonium">Harmonium</option>
                        <option value="Harp">Harp</option>
                        <option value="Organ">Organ</option>
                        <option value="Piano" selected>Piano</option>
                        <option value="Saxophone">Saxophone</option>
                        <option value="Trombone">Trombone</option>
                        <option value="Trumpet">Trumpet</option>
                        <option value="Tuba">Tuba</option>
                        <option value="Violin">Violin</option>
                        <option value="Xylophone">Xylophone</option>
                    </select>
                </div>
              </div>

              <div class="settings-row">
                <div class="input-group" style="flex: 1;">
                  <button id="doc-gen">Generate Pdf</button>
                </div>
              </div>
          
              <div class="settings-row">
              <div class="input-group" style="flex: 1;">
                <button id="save-composition">Save Composition</button>
              </div>
              </div>
            </div>
          </div>
          
          
        <div id="my-stave" class="container"></div>           
    <script>
        const VF = Vex.Flow;
        const divStave = document.getElementById("my-stave");
        const renderer = new VF.Renderer(divStave, VF.Renderer.Backends.SVG);
        const context = renderer.getContext();
        

        // Initial notes array
        let notes = [
            { key: "g/4", duration: "q" },
        ];
        
        // I'm so sorry

        let = scoreTitle = 'Untitled Song';
        let tempo = 120;
        window.tempoInt = tempo;
        let eq = "=";
        let tempoNote = "‚ô©";
        let selectedNoteIndexes = [0]; 
        let lastSelectedIndex = 0;
        let dur = "q";
        let isRestMode = false; 
        let currentKeySignature = 'C'
        let keysigadd = 0;
        let timeSignatureNumerator = 4; 
        let timeSignatureDenominator = 4; 
        let staveWidth = 100*timeSignatureNumerator;
        let rowSpacing = 150;
        let totalRows = 1;
        window.instrument = instrumentDropdown.value; // Change this
        const tutorialBtn = document.getElementById('tutorial-btn');
        const tutorialContainer = document.getElementById('tutorial-container');

        // logic for saving via backend api. 
        const backendUrl = location.hostname === "localhost" 
        ? "http://localhost:5000" 
        : "https://backend-991441480624.us-central1.run.app";        
        document.getElementById('save-composition').addEventListener('click', () => {
        const name = document.getElementById('score-title').value;
        const scoreTitle = document.getElementById('score-title').value;
        const timeSignatureNumerator = document.getElementById("numerator").value.trim();
        const timeSignatureDenominator = document.getElementById("denominator").value.trim();
        const currentKeySignature =  document.getElementById("key-signature").value.trim();
        const tempo = document.getElementById('tempo').value / (document.getElementById("denominator").value / 4);
        const composition = {
            name: name,
            scoreTitle: scoreTitle,
            timeSignatureNumerator: timeSignatureNumerator,
            timeSignatureDenominator: timeSignatureDenominator,
            currentKeySignature:  currentKeySignature,
            tempo: tempo,
            notes: notes  
        };
        if (name && scoreTitle && timeSignatureNumerator && timeSignatureDenominator && currentKeySignature && tempo && notes) {
            try {
                axios.post(backendUrl+"/store_composition", {
                    composition: composition
                }, { withCredentials: true }
                )
                .then(response => {
                    console.log('Composition saved:', response.data);
                    alert("Composition saved successfully!");
                })
                .catch(error => {
                    console.error('Error saving composition:', error);
                    alert("Error saving composition: You must be logged in to save.");
                });
            } catch (error) {
                console.error('Error:', error);
            }

        } else {
            alert("Please enter all fields to save the composition. (title, time signature, key signature, and tempo.)");
        }
        });
        
        // logic for fetching via backend api. (assumption is that user is coming from userProfile to Canvasview.)
        // Parse the query string from the URL
        const urlParams = new URLSearchParams(window.location.search);
        const fromFetch = urlParams.get('from');
        const titleFetch = urlParams.get('title');
        if (fromFetch === 'profile') {
            console.log("User came from userProfile.vue");
            console.log("Title:", titleFetch);
            try {
                axios.post(backendUrl+"/get_composition",{
                    name: titleFetch
                },
                 { withCredentials: true }
                )
                .then(response => {
                    console.log('Composition fetched:', response.data);
                    const data = response.data.composition;
                    scoreTitle = data.scoreTitle;
                    timeSignatureNumerator = data.timeSignatureNumerator;
                    timeSignatureDenominator = data.timeSignatureDenominator;
                    currentKeySignature = data.currentKeySignature;
                    notes = data.notes;
                    tempo = data.tempo;
                    window.tempoInt = data.tempo;
                    renderNotes(); 
                    
                    //alert("Composition fetched successfully!");
                })
                .catch(error => {
                    console.error('Error fetching composition:', error);
                    alert("Error fetching composition: ensure you have saved your composition.");
                }); 
            } 
            catch (error) {
                console.error('Error:', error);
            }

        };


        // Define accidentals for sharp and flat handling
        const halfSteps = {
            c: ["c#", "db"],
            "c#": ["d"],
            db: ["d"],
            d: ["d#", "eb"],
            "d#": ["e"],
            eb: ["e"],
            e: ["f"],
            f: ["f#", "gb"],
            "f#": ["g"],
            gb: ["g"],
            g: ["g#", "ab"],
            "g#": ["a"],
            ab: ["a"],
            a: ["a#", "bb"],
            "a#": ["b"],
            bb: ["b"],
            b: ["c"], 
        };

        const wholeSteps = {
            c: ["d"],
            "c#": ["d#"],
            db: ["eb"],
            d: ["e"],
            "d#": ["f#"],
            eb: ["gb"],
            e: ["f"],
            f: ["g"],
            "f#": ["g#"],
            gb: ["ab"],
            g: ["a"],
            "g#": ["a#"],
            ab: ["bb"],
            a: ["b"],
            "a#": ["c#"],
            bb: ["db"],
            b: ["c"],
        };

        const keysignum = {
            "C":0,
            "G":1,
            "D":2,
            "A":3,
            "E":4,
            "B":5,
            "F#":6,
            "C#":7,
            "F":1,
            "Bb":2,
            "Eb":3,
            "Ab":4,
            "Db":5,
            "Gb":6,
            "Cb":7,
        };

        const reverseHalfSteps = Object.fromEntries(
            Object.entries(halfSteps).flatMap(([note, options]) =>
                options.map((nextNote) => [nextNote, note])
            )
        );

        const reverseWholeSteps = Object.fromEntries(
            Object.entries(wholeSteps).flatMap(([note, options]) =>
                options.map((nextNote) => [nextNote, note])
            )
        );

        // Adjust the SVG height dynamically
        function adjustSVGHeight(totalRows) {
            const newHeight = (totalRows * rowSpacing) + 100;
            renderer.resize(window.innerWidth, newHeight);
        }

        // Function to render the entire stave including multiple measures
        function renderNotes(pdf = false) {
            staveWidth = (70 * timeSignatureNumerator) + keysignum[currentKeySignature]*30; // Default width for measures
            context.clear();
            const titleWidth = context.measureText(scoreTitle).width;
            const centerX = (window.innerWidth - titleWidth) / 2;  // Center it on the screen
            
            const noteMap = { // If not any of these, the quarter will be used.  
                1: "ùÖù",
                2: "ùÖû", 
                4: "‚ô©",
                8: "‚ô™",
                16: "ùÖ°"
            };
            
                tempoNote = noteMap[timeSignatureDenominator] || noteMap[4]; // Default to quarter note if not found

            if(pdf) {

                context.setFont('Arial', 25, 'bold');
                const pdfTitleWidth = context.measureText(scoreTitle).width;
                const pdfCenterX = (window.innerWidth - pdfTitleWidth) / 2;
                context.fillText(scoreTitle, pdfCenterX, 30);

                context.setFont('Arial', 24, 'normal').fillText(tempoNote, 3, 85);
                context.setFont('Arial', 14, 'normal').fillText(eq, 20, 85);
                context.setFont('Arial', 14, 'normal').fillText(tempo, 35, 84);
            } else {
                // Page; Not PDF here
                context.setFont('Arial', 20, 'bold').fillText(scoreTitle, centerX, 30);

                context.setFont('Arial', 24, 'normal').fillText(tempoNote, 3, 30);
                context.setFont('Arial', 12, 'normal').fillText(eq, 20, 30);
                context.setFont('Arial', 12, 'normal').fillText(tempo, 35, 29);
            }


            notes = makeProperMeasure(notes);
            const measures = groupNotesIntoMeasures(notes); // Group notes into measures

            adjustSVGHeight(totalRows);

            let globalIndex = 0; 
            let firstMeasure = true; 
            let measureWidths = []
            for (let measureIndex = 0; measureIndex < measures.length; measureIndex++) {
                let measureNotes = measures[measureIndex];
                staveWidth = (50 * measureNotes.length) 
                let measureStaveWidth = firstMeasure ? staveWidth+keysigadd+ keysignum[currentKeySignature]*20 +100: staveWidth; // Make first measure larger\
                if (firstMeasure) {
                    firstMeasure = false;
                }
                if (window.innerWidth < measureStaveWidth) {
                    alert("Sorry, your screen is too small for the measure.");
                    console.log(measureNotes)
                    while(window.innerWidth-100 < measureStaveWidth) {
                        if (measureNotes.length > 0) {
                            measureNotes = measureNotes.slice(0, measureNotes.length - 1);
                        }
                        staveWidth = (50 * measureNotes.length);
                        measureStaveWidth = firstMeasure ? staveWidth+keysigadd+ keysignum[currentKeySignature]*20 : staveWidth; 
                    }
                    
                    console.log(measureNotes)
                    let notenum = -1;
                    for (let indexn = 0; indexn < measureIndex; indexn++) {
                        const meas = measures[indexn];
                        notenum = notenum + meas.length;
                    }
                    notenum = notenum + measureNotes.length;
                    for (let deleteindex = 0; deleteindex < measures[measureIndex].length-measureNotes.length+1; deleteindex++) {
                        notes.splice(notenum, 1);
                    }
                }
                

                measureWidths.push(measureStaveWidth)
            }
            let availableWidth = window.innerWidth - 100; // Total available width (context)

            // Step 1: Distribute measures into rows based on available width
            let rows = [];
            let currentRow = [];
            let currentRowWidth = 0;

            for (let i = 0; i < measureWidths.length; i++) {
                let measureWidth = measureWidths[i];

                // If adding this measure exceeds the available width, start a new row
                if (currentRowWidth + measureWidth > availableWidth) {
                    rows.push(currentRow); // Push the current row into rows
                    currentRow = [measureWidth]; // Start a new row with the current measure
                    currentRowWidth = measureWidth; // Reset row width to the current measure
                } else {
                    currentRow.push(measureWidth); // Add the measure to the current row
                    currentRowWidth += measureWidth; // Update the current row width
                }
            }

            // Add the last row if any
            if (currentRow.length > 0) {
                rows.push(currentRow);
            }

            // Step 2: Scale the widths of the measures in each row except the last one
            measureWidths = []; // Reset measureWidths to hold the scaled values

            rows.forEach((row, index) => {
                if (index < rows.length - 1) {
                    // If it's not the last row, scale the measures
                    let rowTotalWidth = row.reduce((acc, width) => acc + width, 0); // Total width of current row
                    let scalingFactor = availableWidth / rowTotalWidth; // Scaling factor to fit the row within the available width

                    // Scale each measure width in the row and update measureWidths directly
                    row.forEach(width => {
                        measureWidths.push(Math.round(width * scalingFactor)-1); // Directly push the scaled width to measureWidths
                    });
                } else {
                    // If it's the last row, don't scale, just push the original measure widths
                    row.forEach(width => {
                        measureWidths.push(width); // Add the original width without scaling
                    });
                }
            });
            firstMeasure = true; 
            for (let measureIndex = 0; measureIndex < measures.length; measureIndex++) {
                let measureNotes = measures[measureIndex];
                let measureStaveWidth = measureWidths[measureIndex]
                let position = {x: 0, y: 20}
                if (measureIndex != 0) {
                    position = calculateStavePosition(measureWidths.slice(0, measureIndex+1));
                    console.log(position);
                } 
                let pdfPosY = 0;
                if(pdf) {
                    pdfPosY = 75;
                }
                
                const stave = new VF.Stave(position.x, position.y + pdfPosY, measureStaveWidth);
                
                if (firstMeasure) {
                    stave.addClef("treble").addTimeSignature(timeSignatureNumerator + "/" + timeSignatureDenominator).addKeySignature(currentKeySignature);
                    firstMeasure = false; 
                }

                stave.setContext(context).draw();

                // Fixed time signature: 4 beats per measure
                const voice = new VF.Voice({ num_beats: timeSignatureNumerator, beat_value: timeSignatureDenominator });
                //voice.setStrict(false); 
                const brackets = []; // Store 8va brackets
                let firstHighNote = null;
                let lastHighNote = null;
                let firstLowNote = null;
                let lastLowNote = null;
                const measureTickables = measureNotes.map((note, index) => {
                    // Extract note and octave
                    const [pitch, octave] = note.key.split("/");
                    const octaveNum = parseInt(octave);

                    let staveNote;

                    // If octave is 6 or higher, create a new stave note with the octave lowered for visual 8va effect (octave up)
                    if ((octaveNum == 6 && ((pitch.startsWith("a")) || (pitch.startsWith("b")) || (pitch.startsWith("g")))) || (octaveNum >=7)) {
                        let oct = 6;
                        if (octaveNum == 6 || (pitch.startsWith("a")) || (pitch.startsWith("b")) || (pitch.startsWith("g"))) {
                            oct = 5;
                        }
                        staveNote = new VF.StaveNote({
                            clef: "treble",
                            keys: [`${pitch}/${oct}`],  // Lower octave
                            duration: note.duration,
                        });
                    } 
                    // If octave is 5 or lower, create a new stave note with the octave raised for visual 8vb effect (octave down)
                    else if (octaveNum <= 2 || (octaveNum == 3 && ((pitch.startsWith("e")) || (pitch.startsWith("d")) || (pitch.startsWith("c"))))) {
                        let oct = 3;
                        if (octaveNum == 3 || (pitch.startsWith("e")) || (pitch.startsWith("d")) || (pitch.startsWith("c"))) {
                            oct = 4;
                        }
                        staveNote = new VF.StaveNote({
                            clef: "treble",
                            keys: [`${pitch}/${oct}`],  // Raise octave
                            duration: note.duration,
                        });
                    } 
                    else {
                        staveNote = new VF.StaveNote({
                            clef: "treble",
                            keys: [note.key],
                            duration: note.duration,
                        });
                    }

                    // Add dot if it's a dotted note
                    if (note.duration.includes("d")) {
                        staveNote.addDotToAll();
                    }

                    // Highlight the selected note by comparing global index
                    if (selectedNoteIndexes.includes(globalIndex) && !pdf) {
                        staveNote.setStyle({ fillStyle: "red", strokeStyle: "red" });
                    }

                    // Track high notes for 8va
                    if ((octaveNum == 6 && ((pitch.startsWith("a")) || (pitch.startsWith("b")) || (pitch.startsWith("g")))) || (octaveNum >=7)) {
                        if (!firstHighNote) firstHighNote = staveNote;
                        lastHighNote = staveNote;
                    }

                    // Track low notes for 8vb
                    if (octaveNum <= 2 || (octaveNum == 3 && ((pitch.startsWith("e")) || (pitch.startsWith("d")) || (pitch.startsWith("c"))))) {
                        if (!firstLowNote) firstLowNote = staveNote;
                        lastLowNote = staveNote;
                    }

                    globalIndex++; 
                    return staveNote;
                });

                // Add text brackets for "8va" (octave up) and "8vb" (octave down)
                if (firstHighNote && lastHighNote) {
                    const textBracket = new VF.TextBracket({
                        start: firstHighNote,
                        stop: lastHighNote,
                        text: "8va",  // 8va for high notes
                        position: VF.TextBracket.Positions.TOP,
                    });
                    textBracket.setLine(3);
                    brackets.push(textBracket);
                }
                
                if (firstLowNote && lastLowNote) {
                    const textBracket = new VF.TextBracket({
                        start: firstLowNote,
                        stop: lastLowNote,
                        text: "8vb",  // 8vb for low notes
                        position: VF.TextBracket.Positions.BOTTOM,
                    });
                    textBracket.setLine(3);
                    brackets.push(textBracket);
                }

                var beams = VF.Beam.generateBeams(measureTickables, {groups: [new Vex.Flow.Fraction(1, 4)]});
                
                voice.addTickables(measureTickables);
                VF.Accidental.applyAccidentals([voice], currentKeySignature);
                if (measureIndex == 0) {
                    const formatter = new VF.Formatter({ softmaxFactor: 1 }).joinVoices([voice]).format([voice], measureStaveWidth-100);
                } else {
                    const formatter = new VF.Formatter({ softmaxFactor: 1 }).joinVoices([voice]).format([voice], measureStaveWidth);
                }
                console.log("Voice complete?", voice.isComplete());
                console.log("Total ticks:", voice.getTotalTicks().toString());
                voice.draw(context, stave);
                brackets.forEach(bracket => bracket.setContext(context).draw());
                if (Array.isArray(beams)) {
                    beams.forEach(function(b) {
                        b.setContext(context).draw();
                    });
                } else {
                    console.error("Beams is not an array:", beams);
                }

            };
            window.vexNotes = notes;
            attachClickEvents();
        }
        // Group notes into measures
        function groupNotesIntoMeasures(notes) {
            const measures = [];
            let currentMeasure = [];
            let currentBeats = 0;

            const durationValues = {
                "w": timeSignatureDenominator,
                "hd": timeSignatureDenominator * 0.75,
                "h": timeSignatureDenominator * 0.5,
                "q": timeSignatureDenominator * 0.25,
                "8": timeSignatureDenominator * (1/8),
                "16": timeSignatureDenominator * (1/16),
                "wr": timeSignatureNumerator,
                "hdr": timeSignatureDenominator * 0.75,
                "hr": timeSignatureDenominator * 0.5,
                "qr": timeSignatureDenominator * 0.25,
                "8r": timeSignatureDenominator * (1/8),
                "16r": timeSignatureDenominator * (1/16)
            };

            notes.forEach(note => {
                const beats = durationValues[note.duration] || 1; 
                if (currentBeats + beats > timeSignatureNumerator) {
                    measures.push(currentMeasure);
                    currentMeasure = [];
                    currentBeats = 0;
                }
                currentMeasure.push(note);
                currentBeats += beats;
            });
            measures.push(currentMeasure);
            return measures;
        }

        // Function to add rests
        function makeProperMeasure(notes) {
            const resultNotes = [];
            let currentMeasure = [];
            let currentBeats = 0;
            const allRests = true;

            const durationValues = {
                "w": timeSignatureDenominator,
                "hd": timeSignatureDenominator * 0.75,
                "h": timeSignatureDenominator * 0.5,
                "q": timeSignatureDenominator * 0.25,
                "8": timeSignatureDenominator * (1/8),
                "16": timeSignatureDenominator * (1/16),
                "wr": timeSignatureNumerator,
                "hdr": timeSignatureDenominator * 0.75,
                "hr": timeSignatureDenominator * 0.5,
                "qr": timeSignatureDenominator * 0.25,
                "8r": timeSignatureDenominator * (1/8),
                "16r": timeSignatureDenominator * (1/16)
            };

            notes.forEach(note => {
                const beats = durationValues[note.duration] || 1;
                if(durationValues[note.duration] <= timeSignatureNumerator) {
                    if (currentBeats + beats > timeSignatureNumerator) {
                        while (currentBeats < timeSignatureNumerator) {
                            const restDuration = getRestDuration(timeSignatureNumerator - currentBeats);
                            currentMeasure.push({ key: "b/4", duration: restDuration + "r" });
                            currentBeats += durationValues[restDuration];
                        }
                        if (isMeasureAllRests(currentMeasure) && !containsWholeRest(currentMeasure)) {
                            console.log("Skipping measure with only rests (except whole rest).");
                        } else {
                            resultNotes.push(...currentMeasure);
                        }

                        currentMeasure = [];
                        currentBeats = 0;
                    }

                    currentMeasure.push(note);
                    currentBeats += beats;
                }
                
            });

            while (currentBeats < timeSignatureNumerator) {
                const restDuration = getRestDuration(timeSignatureNumerator - currentBeats);
                currentMeasure.push({ key: "b/4", duration: restDuration + "r" });
                currentBeats += durationValues[restDuration];
            }
            if (isMeasureAllRests(currentMeasure) && !containsWholeRest(currentMeasure)) {
                console.log("Skipping last measure with only rests (except whole rest).");
            } else {
                resultNotes.push(...currentMeasure); 
            }

            return resultNotes;
        }

        // Helper function to check if a measure contains only rests (excluding whole rests)
        function isMeasureAllRests(measure) {
            return measure.every(note => note.duration.endsWith("r"));
        }

        // Helper function to check if a measure contains at least one whole rest
        function containsWholeRest(measure) {
            return measure.some(note => note.duration === "wr");
        }


        // Helper function to determine the rest duration based on the remaining beats
        function getRestDuration(remainingBeats) {
            if (remainingBeats === timeSignatureNumerator) return "w"; // Whole rest
            if (remainingBeats >= timeSignatureDenominator*(3/4)) return "hd"; // Dotted half rest
            if (remainingBeats >= timeSignatureDenominator*(1/2)) return "h"; // Half rest
            if (remainingBeats >= timeSignatureDenominator*(1/4)) return "q"; // Quarter rest
            if (remainingBeats >= timeSignatureDenominator*(1/8)) return "8"; // Eighth rest
            return "16"; // Default to sixteenth rest
        }


        // Calculate stave positions
        function calculateStavePosition(measureWidths) {
            const screenWidth = window.innerWidth - 50;
            let x_value = 0; 
            let y_value = 20;
            let rowIndex = 1;
            
            // Loop through all measures to calculate accumulated width
            for (let i = 0; i < measureWidths.length; i++) {
                if (x_value + measureWidths[i] > screenWidth) {
                    // Move to the next row if the measure exceeds screen width
                    y_value += rowSpacing;
                    x_value = 0; 
                    rowIndex += 1;
                }

                // After checking if the measure fits, add it to the current row
                x_value += measureWidths[i];
            }

            totalRows = rowIndex;
            return {
                x: x_value - measureWidths[measureWidths.length-1],
                y: y_value,
            };
        }

        // Attach click events to the notes
        function attachClickEvents() {
            const noteGroups = divStave.querySelectorAll("svg g.vf-stavenote");
            noteGroups.forEach((group, index) => {
                group.addEventListener("click", (event) => {
                    event.stopPropagation();
                    if (event.shiftKey && lastSelectedIndex !== null) {
                        selectedNoteIndexes = [];
                        const start = Math.min(lastSelectedIndex, index);
                        const end = Math.max(lastSelectedIndex, index);
                        for (let i = start; i <= end; i++) {
                            selectedNoteIndexes.push(i);
                        }
                    } else if (event.ctrlKey || event.metaKey) {
                        // Toggle note selection
                        if (selectedNoteIndexes.includes(index)) {
                            selectedNoteIndexes = selectedNoteIndexes.filter(i => i !== index);
                        } else {
                            selectedNoteIndexes.push(index);
                        }
                        lastSelectedIndex = index;
                    } else {
                        // Single click without modifiers
                        selectedNoteIndexes = [index];
                        lastSelectedIndex = index;
                    }
                    renderNotes();
                });
            });
        }

        // Move note by a half step (up or down)
        function moveNoteHalfStep(index, direction) {
            if (index === null || index < 0 || index >= notes.length) return;
            if (notes[index].duration.includes("r")) return;
            const [note, octave] = notes[index].key.split("/");

            let newNote;
            if (direction === "up") {
                newNote = halfSteps[note] ? halfSteps[note][0] : note;
                if (newNote === "c") notes[index].key = `${newNote}/${+octave + 1}`; // Handle octave change
                else notes[index].key = `${newNote}/${octave}`;
            } else if (direction === "down") {
                newNote = reverseHalfSteps[note] || note;
                if (newNote === "b") notes[index].key = `${newNote}/${+octave - 1}`; 
                else notes[index].key = `${newNote}/${octave}`;
            }

            renderNotes();
        }

        function moveNoteWholeStep(index, direction) {
            if (index === null || index < 0 || index >= notes.length) return;
            if (notes[index].duration.includes("r")) return;
            const [note, octave] = notes[index].key.split("/");

            let newNote;
            if (direction === "up") {
                newNote = wholeSteps[note] ? wholeSteps[note][0] : note;
                if (newNote === "c" || newNote === "c#" || newNote === "db") notes[index].key = `${newNote}/${+octave + 1}`; // Handle octave change
                else notes[index].key = `${newNote}/${octave}`;
            } else if (direction === "down") {
                newNote = reverseWholeSteps[note] || note;
                if (newNote === "b" || newNote === "a#" || newNote === "bb") notes[index].key = `${newNote}/${+octave - 1}`; // Handle octave change
                else notes[index].key = `${newNote}/${octave}`;
            }

            renderNotes();
        }
        console.log("Adding keydown event listener...");

        // Key event listeners
        document.addEventListener("keydown", function(event) {
            const activeTag = document.activeElement.tagName.toLowerCase();
            if (activeTag === "input" || activeTag === "textarea") {
                return; // Don't trigger note input while typing in settings
            }

            console.log(`Key: ${event.key}, Shift: ${event.shiftKey}`);

            if (event.key === "W" && event.shiftKey) {
                console.log("Shift + W detected ‚Üí Move Half Step Up");
                selectedNoteIndexes.forEach(index => moveNoteHalfStep(index, "up"));
            } else if (event.key === "w") {
                selectedNoteIndexes.forEach(index => moveNoteWholeStep(index, "up"));
            } else if (event.key === "S" && event.shiftKey) {
                selectedNoteIndexes.forEach(index => moveNoteHalfStep(index, "down"));
            } else if (event.key === "s") {
                selectedNoteIndexes.forEach(index => moveNoteWholeStep(index, "down"));
            } else if (event.key === "ArrowRight") {
                if (selectedNoteIndexes.length > 0) {
                    let maxIndex = Math.max(...selectedNoteIndexes);
                    selectedNoteIndexes = [(maxIndex + 1) % notes.length];
                    lastSelectedIndex = selectedNoteIndexes[0];
                    renderNotes();
                }
            } else if (event.key === "ArrowLeft") {
                if (selectedNoteIndexes.length > 0) {
                    let minIndex = Math.min(...selectedNoteIndexes);
                    selectedNoteIndexes = [(minIndex - 1 + notes.length) % notes.length];
                    lastSelectedIndex = selectedNoteIndexes[0];
                    renderNotes();
                }
            } else if (event.key === "a") {
                let newNote;

                if (selectedNoteIndexes.length === 0) {
                    newNote = isRestMode
                        ? { key: "b/4", duration: dur + "r" }
                        : { key: "g/4", duration: dur };
                    notes.push(newNote);
                    selectedNoteIndexes = [notes.length - 1];
                    lastSelectedIndex = notes.length - 1;
                } else {
                    let maxIndex = Math.max(...selectedNoteIndexes);
                    const refNote = notes[maxIndex];

                    if (refNote.duration.includes("r")) {
                        // Copy rest or use default note
                        newNote = isRestMode
                            ? { key: "b/4", duration: dur + "r" }
                            : { key: "g/4", duration: dur };
                    } else {
                        // Copy key and octave from selected note
                        newNote = isRestMode
                            ? { key: "b/4", duration: dur + "r" }
                            : { key: refNote.key, duration: dur };
                    }

                    // Add new note after the selected one
                    if (maxIndex === notes.length - 1) {
                        notes.push(newNote);
                        selectedNoteIndexes = [notes.length - 1];
                        lastSelectedIndex = notes.length - 1;
                    } else {
                        notes.splice(maxIndex + 1, 0, newNote);
                        selectedNoteIndexes = [maxIndex + 1];
                        lastSelectedIndex = maxIndex + 1;
                    }
                }
                renderNotes();
            } else if (event.key === "Delete" && selectedNoteIndexes.length > 0) {
                notes = notes.filter((_, index) => !selectedNoteIndexes.includes(index));
                selectedNoteIndexes = [];
                lastSelectedIndex = null;
                renderNotes();                          
            } else if (event.key === "r") {
                isRestMode = !isRestMode; 
                const restButton = document.getElementById("rest-button");

                // Toggle the active class to change the button's appearance
                if (isRestMode) {
                    restButton.classList.add("active"); 
                } else {
                    restButton.classList.remove("active"); 
                }
            } else if (event.key === "1") {
                const noteIcon = document.getElementById("note-icon");
                dur = "w"; 
                noteIcon.src = "images/whole.svg"; 
            } else if (event.key === "3") {
                const noteIcon = document.getElementById("note-icon");
                dur = "h"; 
                noteIcon.src = "images/half.png";
            } else if (event.key === "2") {
                const noteIcon = document.getElementById("note-icon");
                dur = "hd"; 
                noteIcon.src = "images/dotted.svg"; 
            } else if (event.key === "4") {
                const noteIcon = document.getElementById("note-icon");
                dur = "q"; 
                noteIcon.src = "images/quarter.png"; 
            } else if (event.key === "5") {
                const noteIcon = document.getElementById("note-icon");
                dur = "8"; 
                noteIcon.src = "images/eighth.png";
            } else if (event.key === "6") {
                const noteIcon = document.getElementById("note-icon");
                dur = "16";
                noteIcon.src = "images/sixteenth.png"; 
            }
        });

        document.addEventListener("DOMContentLoaded", () => {
            const noteButton = document.getElementById("note-button");
            const noteIcon = document.getElementById("note-icon");
            const noteOptions = document.getElementById("note-options");
            const noteButtons = document.querySelectorAll(".note-option");
            syncSettingsPanel();
            // Get the input fields
            const scoreTitleInput = document.getElementById('score-title');
            const keySignatureInput = document.getElementById('key-signature');
            const numeratorInput = document.getElementById('numerator');
            const denominatorInput = document.getElementById('denominator');
            const tempoInput = document.getElementById('tempo');

            // Event listener for "Enter" key on settings inputs
            scoreTitleInput.addEventListener('keydown', (event) => {
                if (event.key === 'Enter') {
                    scoreTitle = scoreTitleInput.value;
                    renderNotes(); 
                }
            });

            keySignatureInput.addEventListener('keydown', (event) => {
                if (event.key === 'Enter') {
                    const inputKey = keySignatureInput.value.trim();
                    const validKeySignatures = ["C", "G", "D", "A", "E", "B", "F#", "C#", "F", "Bb", "Eb", "Ab", "Db", "Fb", "Cb"];
                    
                    if (validKeySignatures.includes(inputKey)) {
                        currentKeySignature = inputKey; 
                        renderNotes();
                    } else {
                        alert("Invalid key signature. Please enter a valid key signature.");
                    }
                }
            });

            numeratorInput.addEventListener('keydown', (event) => {
                if (event.key === 'Enter') {
                    const numerator = numeratorInput.value.trim();
                    const denominator = denominatorInput.value.trim();
                    if (numerator && denominator) {
                        const num = parseInt(numerator);
                        const denom = parseInt(denominator);
                        const validDenoms = [1, 2, 4, 8, 16]
                        if (denom <= 0 || num <= 0) {
                            alert("Sorry, numbers less than 1 are not valid in a time signature.");
                        } else if (!validDenoms.includes(denom)){
                            alert("Sorry, denominators other than 1, 2, 4, 8, or 16 are not valid in a time signature.");
                        } else {
                            timeSignatureNumerator = num;
                            timeSignatureDenominator = denom;
                            renderNotes(); 
                        }
                    }
                }
            });
            denominatorInput.addEventListener('keydown', (event) => {
                if (event.key === 'Enter') {
                    const numerator = numeratorInput.value.trim();
                    const denominator = denominatorInput.value.trim();
                    if (numerator && denominator) {
                        const num = parseInt(numerator);
                        const denom = parseInt(denominator);
                        if (denom <= 0 || num <= 0) {
                            alert("Sorry, numbers less than 1 are not valid in a time signature.");
                        } else {
                            timeSignatureNumerator = num;
                            timeSignatureDenominator = denom;
                            renderNotes(); 
                        }
                    }
                }
            });

            tempoInput.addEventListener('keydown', (event) => {
                if (event.key === 'Enter') {
                    const tempoValue = tempoInput.value;
                    if (tempoValue) {
                        window.tempoInt = tempoValue;
                        tempo = tempoValue;
                        renderNotes();
                    }
                }
            });
            noteButtons.forEach(button => {
                button.addEventListener("click", (event) => {
                    const selectedNote = event.currentTarget.getAttribute("data-value");
                    const selectedImage = event.currentTarget.querySelector("img").src;
                    dur = selectedNote; 
                    noteIcon.src = selectedImage; 

    
                    noteOptions.style.display = "none";
                });
            });

            // Ensure clicking the button shows the dropdown
            noteButton.addEventListener("click", () => {
                noteOptions.style.display = noteOptions.style.display === "flex" ? "none" : "flex";
            });

            // Close dropdown when clicking anywhere outside
            document.addEventListener("click", (event) => {
                if (!noteSelection.contains(event.target)) {
                    noteOptions.style.display = "none";
                }
            });
        });
        document.getElementById("rest-button").addEventListener("click", () => {
            isRestMode = !isRestMode; 
            const restButton = document.getElementById("rest-button");

            if (isRestMode) {
                restButton.classList.add("active"); 
            } else {
                restButton.classList.remove("active"); 
            }
        });

        document.getElementById("update-key").addEventListener("click", () => {
            const inputKey = document.getElementById("key-signature").value.trim();
            const validKeySignatures = ["C", "G", "D", "A", "E", "B", "F#", "C#", "F", "Bb", "Eb", "Ab", "Db", "Fb", "Cb"];

            if (validKeySignatures.includes(inputKey)) {
                currentKeySignature = inputKey; 
                renderNotes(); 
            } else {
                alert("Invalid key signature. Please enter a valid key signature.");
            }
        });
        document.addEventListener("click", (event) => {
            const svgElement = divStave.querySelector("svg");
            if (!svgElement.contains(event.target) && !event.shiftKey) {
                selectedNoteIndexes = [];
                lastSelectedIndex = null;
                renderNotes();
            }
        });
        document.getElementById("update-time").addEventListener("click", () => {
            const numerator = document.getElementById("numerator").value.trim();
            const denominator = document.getElementById("denominator").value.trim();

            // Check if numerator and denominator are provided
            if (numerator && denominator) {
                // Convert input to integers
                const num = parseInt(numerator);
                const denom = parseInt(denominator);

                const requiredWidth = 100 * num; 

                const screenWidth = window.innerWidth;

                // If the time signature width exceeds the screen width, show a popup and don't update the time signature
                if (requiredWidth > screenWidth) {
                    alert("Sorry, your screen is too small for this time signature.");            
                } 
                else if (denom <=0 || num <= 0){
                    alert("Sorry, numbers less than 1 are not valid in a time signature.");
                }
                else {
                    // Otherwise, update the time signature
                    timeSignatureNumerator = num;
                    timeSignatureDenominator = denom;
                    window.timeSignNum = num;
                    window.timeSignDenom = denom;
                    renderNotes(); 
                }
            }
        });
        document.getElementById('settings-toggle').addEventListener('click', () => {
            document.getElementById('settings-panel').classList.toggle('collapsed');
            syncSettingsPanel();
        });
        document.getElementById('update-title').addEventListener('click', function() {
            scoreTitle = document.getElementById('score-title').value;
            renderNotes(); 
        });
        document.getElementById('set-tempo').addEventListener('click', function() {
            tempo = document.getElementById('tempo').value;
            renderNotes();  
        });
        
        tutorialBtn.addEventListener('click', function(e) {
            e.stopPropagation(); // Prevent click from bubbling up if necessary
            tutorialContainer.classList.toggle('active');
        });
        document.addEventListener('click', function(e) {
            if (!tutorialContainer.contains(e.target)) {
                tutorialContainer.classList.remove('active');
            }
        });
        // Tempo Changes
        document.getElementById('set-tempo').addEventListener('click', function() {
            if(document.getElementById('tempo').value == undefined) {
                console.log("Tempo is undefined");
            } else {
                window.tempoInt = document.getElementById('tempo').value;
            }
        });

        renderNotes();
    </script>
    <script src="ToneJS.js"></script>
    <script>
        document.getElementById("doc-gen").addEventListener("click", () => {
            const staves = document.getElementById("my-stave");
            const prevStaff = staves.style.border;
            staves.style.border = 'none';

            const staffOpt = {
                margin: [0.25, 0.5, 0.75, 0.5],
                filename: 'sheet-music.pdf',
                image: { type: 'jpeg', quality: 0.98 },
                html2canvas: { scale: 1, width: 1280 },
                jsPDF: { unit: 'in', format: 'a4', orientation: 'portrait' }
            };
            renderNotes(pdf = true);
            html2pdf().from(staves).set(staffOpt).toPdf().get('pdf').then(function (pdf) {
                window.open(pdf.output('bloburl'), '_blank');
                setTimeout(() => {                   // For handling with elements to be shown/hidden in the PDF
                    staves.style.border = prevStaff; // For showing the border later
                    renderNotes();
                }, 1);
            });
        });
        function syncSettingsPanel() {
            document.getElementById('score-title').value = scoreTitle;
            document.getElementById('key-signature').value = currentKeySignature;
            document.getElementById('numerator').value = timeSignatureNumerator;
            document.getElementById('denominator').value = timeSignatureDenominator;
            document.getElementById('tempo').value = tempo;
            document.getElementById('tempo').value = window.tempoInt;
        }
        
        //document.addEventListener("DOMContentLoaded", () => {
         //   syncSettingsPanel();  // Sync on page load
        //});

        //document.getElementById('settings-toggle').addEventListener('click', () => {
        //    document.getElementById('settings-panel').classList.toggle('collapsed');
        ///    syncSettingsPanel();  // Sync on toggle
        //});
    </script>
    <!---<script>
        document.getElementById("doc-gen").addEventListener("click", () => {
            const container = document.createElement("div");
            container.id = "sheetMusicPDF";

            const title = document.createElement("div");
            title.innerText = document.getElementById("score-title").innerText;

            console.log(title);

            const tempo = document.createElement("div");
            tempo.innerText = document.getElementById("tempo").innerText;

            const staves = document.getElementById("my-stave");
            //console.log(title);

            const prevStaff = staves.style.border;
            // const prevTitle = title.style.border;
            // const prevTitleFont = title.style.fontSize;
            // const prevTempo = tempo.style.border;

            //title.style.fontSize = '90px';
            staves.style.border = 'none'; 

            container.appendChild(title);
            container.appendChild(tempo);
            container.appendChild(staves);

            document.body.appendChild(container);
            html2pdf()
                .from(container)
                .set({
                    margin: 0.5,
                    filename: 'sheet-music.pdf',
                    image: { type: 'jpeg', quality: 0.98 },
                    html2canvas: { scale: 1, width: 1280 },
                    jsPDF: { unit: 'in', format: 'a4', orientation: 'portrait' }
                })
                .toPdf().get('pdf').then(function (pdf) {
                window.open(pdf.output('bloburl'), '_blank');
                setTimeout(() => {              // For handling with elements to be shown/hidden in the PDF
                    staves.style.border = prevStaff; // For showing the border later
                    //title.style.display = 'none';
                    //tempo.style.display = 'none';
                }, 1000);


            });
        });
    </script>-->
</body>
</html>
